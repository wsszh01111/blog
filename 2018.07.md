# 2018.07

## 7.3

### 接口进化史

0. 原始阶段
    
通常使用fetch调用接口时，fetch返回Promise，在then的callback中处理结果。通常在定接口文档时，会有多个值标识返回状态，如0表示成功，1表示失败等
```
const checkStatus = (rsp) => {//检查Http状态}
const parseJson = (rsp) => {//解析json}

fetch(url, args).then(checkStatus).then(parseJson).then(rsp=>{
    //在这里处理结果
    if(rsp.state === 0){
        ...
    }else{
        ...
    }
})
```
没有封装，接口一多会显得十分混乱

1. 农业文明

对请求进行一个封装，在其基础之上封装service.js
```
const request = (url, args) => fetch(url args).then(checkStatus).then(parseJson);

// 在service中 可以封装URL的公共部分，可以封装公共参数，也可以针对每个接口的需求不同调整不同的参数修改

const commonURL = '...'; //公共URL
const commonArgs = {}; //公共参数
export const interface1 = (args1) => request(`${commonURL}/url1/url1`， {...commonArgs, ...args1})
export const interface2 = (args2) => request(`${commonURL}/url2/url2`， {...commonArgs, ...args2})

interface1(args).then(rsp=>{
    if(rsp.state === 0){
        ...
    }else{
        ...
    }
})
interface1(args).then(rsp=>{
    if(rsp.state === 0){
        ...
    }else{
        ...
    }
})
```

有了不错的封装，平常用用还可以，但是感觉后期维护问题比较大，接口多了，就不知道每个接口的每种响应状态对应的实际意义，得去查文档，比较麻烦

2. 工业革命

在上面的基础上，将所有的响应状态和请求绑定到一起

```
export Interface1 = {
    request:(args2) => request(`${commonURL}/url2/url2`， {...commonArgs, ...args2}),
    RSP_SUCCESS:0, RSP_SUCCESS_DESC:'成功', //由前端控制话术
    RSP_FAIL:0, RSP_FAIL_DESC:'失败', //由前端控制话术
}
Interface1.request(args)
    .then(rsp=>{
        switch(rsp.state){
            case Interface1.RSP_SUCCESS:
                console.log(Interface1.RSP_SUCCESS_DESC)
                break;
            default: //Interface1.RSP_FAIL
                console.log(Interface1.RSP_FAIL_DESC)
                break;
        }
    })
```
感觉比上一个好一些，从宏观上来看，每个响应参数和请求绑定到一起，更加具有统一的美感。但是，实际开发中会发现，大部分响应参数以及对应的对应方式是相一致的，比如每个参数必有失败，大部分接口必有身份验证失败或身份无效，每次都要写想同的失败响应，多余而难看

3. 21世纪

解决重复的响应问题，且能保持一定的扩展性，相较之前的复杂一些
```

// failHandler在每个接口执行的时候，根据传参，生成一个与之对应的'错误响应处理器'  failRspHandler是一个对象，包含了该接口的错误代码及响应方法
const failHandler = (failRspHandler) => (rsp) => {
        const rspHande = failRspHandler[rsp.status]; //看看
        if (rspHande) rspHande();
        return rsp;
    }
    
const failRspHandler = {
    1: throw new Error('系统错误'), //最后一定要抛出错误 不然会继续执行到下一个then
    2: throw new Error('参数错误'),
}

const request = (url, failRspHandler, args) => fetch(url, args).then(checkStatus).then(parseJson).then(failHandler(failRspHandler));

const Interface = (args) => request(`${commonURL}/url/url`，failRspHandler, {...commonArgs, ...args})

Interface(args).then(rsp=>{
    // 仅在这里处理成功的情况即可 
    // 因为失败的情况类似（给个提示之类的）但成功要处理的情况就大相径庭了 
    // 所以把失败的情况都封装起来 在调用接口的地方只需要处理成功
})

```

## 7.2

### 创建数组且每个元素的值等于其下标的几种方式

今天正好碰到这个需求，用for太low，Google了几种方式做个记录

1. 陷阱

这里依然会返回长度为10 值均为undefined(empty)的数据 [empty × 10]

```
Array(10).map((item, i)=>i); 
//Array(10)和new Array(10)效果是一样的
// 这里依然会返回长度为10 值均为undefined(empty)的数据
// 是因为当数组中的元素未被赋值(assign)过或被delete了 则不会调用map中的callback函数（forEach, reduce也是这样） 直接返回undefined(empty) 
```

2. join和split
```
Array(100).join(",").split(",").map(function(key,index){return index;}) 
//先join再split 通过这种方式避免了1中提到的map的callback的调用限制 

Array(100).toString().split(',').map(function(key,index){return index;}); 
//本质和上面相同 array的toString内部也是调用了join
```

3. 通过Array.from创建数组
```
Array.from({length:10}, (item, i)=>i);
// 采用Array.from构建数组 在构建的过程中每个值都会调用第二个参数传入的callback函数
```

4. apply和call

```
Object.keys(Array.apply(null, {length: 10}))); 
//其实是ES5版的Array.from 从ES5起 apply的第二个参数可以是一个数组 也可以是一个类数组对象！
// 如果是类数组对象 则也会看作是数组 如{length:2} 会在内部当做[undefined, undefined]
// 第一个参数 在非严格模式下 null或undefined会被替换为window
// Object.keys返回数组索引 不过注意是字符串形式的 ['0', '1']

Array.prototype.slice.call({length: 2}); //会生成[empty × 2] slice本是用来分割的 却也可以用来生成数组 奇淫技巧了
```

5. Array.from(new Array(10).keys());

```
Array.from(new Array(100).keys()); 
//ES6新增了keys()方法 返回数组的索引 是一个迭代器对象 
// Array.from的入参可以是类数组对象 也可以是一个迭代器！
```

6. 终极

```
[...Array(100).keys()] //直接通过扩展操作符扩展出所有索引
[...Array.from({ length: 100 }).keys()] //同理
```

综上，如果需要的是字符串数组，则用第4种；数字数组且需要有偏移量的，用第3种；使用ES6没有环境问题的就用第6种

> 发现的一个区别：即通过array.from和array.apply生成的都能被Object.keys()导出，直接Array()的就不行。推测是因为new Array()或Array()时（[empty × 10]），只生成了一个变量，实际并没有对数组分配内存，而由其他方式生成数组的时候，已经分配了内存。具体原因还有待研究

