# 2018.09

## 9.3

### nodejs中的Event Loop

当nodejs启动时，其会初始化event loop，执行程序脚本（包括执行异步API，安排定时器或者是调用process.nextTick()），之后开始执行event loop。nodejs的event loop分成timers、pending callbacks、idle, prepare 、poll、check、close callbacks六个阶段，每个阶段都有各自对应的callback queue。各个阶段详述如下：

1. timers：timers阶段执行setTimeout和setInterval所设置的callback。定时器所提供的是一个时间阀值而不是准确的执行时间，因为系统调度或是执行其他回调将延迟定时器所设定的回调的执行。因为nodejs会在poll阶段判断定时器是否达到时间点，因此poll阶段将决定定时器callback何时执行（或者说极大的影响callback执行时间）

2. pending callbacks：将执行上一个event loop的所推迟的I/O callback（如TCP errors）

3. poll：poll阶段有两个主要功能，即计算分给I/O事件的堵塞轮询时间并执行poll queue中的所有callback，进入poll阶段时，主要逻辑如下：

- poll queue不为空，则同执行所有脚本直到poll queue为空或超过系统限制
- poll queue为空，检查是否有setImmediate
    - 是，则直接到到check阶段执行setImmediate脚本
    - 否，检查是否有定时器到达时间阀值
        - 有，则跳回到timers阶段执行callback
        - 没有，则按照计算的时间堵塞直到有I/O事件完成

4. check：此阶段允许人员在轮询阶段完成后立即执行回调。即setImmediate通过libuv API来安排callback在poll阶段后立即执行

5. close callback：各种关闭事件将在此阶段触发（如socket.destroy()）。或者这些关闭事件将由process.nextTick()触发

#### setImmediate() vs setTimeout()

- setImmediate()安排脚本在poll阶段结束后立即执行
- setTimeout()安排脚本在指定时间阀值之后执行

他们的执行顺序将依赖于其所处的上下文环境，如果它们都没有主模块（即nodejs自带模块）所调用，则他们的执行顺序将受到进程性能的影响，如果都被主模块调用，则setImmediate始终先于setTimeout，因为主模块中大部分都是I/O事件，根据event loop逻辑，I/O事件执行完，poll queue为空且有脚本通过setImmediate设置，则执行setImmediate，将在下一个event loop的timers阶段再执行setTimeout所安排的callback

#### process.nextTick()

process.nextTick()将在当前脚本所处阶段的最后执行。坏处是通过进行递归 process.nextTick()，可以“饿死”I/O调用，阻止事件循环到达poll阶段。之所以这样做是因为API应该始终是异步的设计理念造成的。在以下两种情况下可以使用process.nextTick()：

1. 允许用户处理错误，清理任何不需要的资源，或者在事件循环继续之前重试请求。
2. 有时在调用堆栈已解除但在事件循环继续之前，必须允许回调运行。

Ref:
1. [nodejs/The Node.js Event Loop, Timers, and process.nextTick()](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick)

## 9.1

### Event Loop

macro-task queue和micro-task queue分别存放不同的task（macro-task包括script，setTimeout，setInterval，setImmediate，I/O，UI rendering；micro-task包括process.nextTick，Promises，Object.observe，MutationObserver），js引擎执行过程中，会先取出macro-task queue的第一个task，完成后按次序执行micro-task queue中的所有task，依次循环下去。在线程执行的过程中，随着函数的调用会形成a stack of frames（帧栈），frame中包含了函数的arguments and local variables（参数和本地变量），其余的非结构化数据则会存在Heap（堆）中

Ref:
1. [Macrotask Queue和Microtask Queue](https://www.jianshu.com/p/3ed992529cfc)
2. [MDN/并发模型与事件循环](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop)